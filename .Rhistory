mu1 = mean1
mu2 = mean2
mu3 = mean3
var1 = variance1
var2 = variance2
var3 = variance3
phis = phis_new
}
#Converting var into matrix in order to inout it into dmvnorm function
mu1 <- c(-10, -8)  # Mean of cluster 1
var1 <- matrix(c(3,0,0,2),nrow=2)    # Variances of cluster 1
mu2 <- c(12, -4)   # Mean of cluster 2
var2 <- matrix(c(4,0,0, 2.5),nrow=2)  # ...etc...
mu3 <- c(4, 18)
var3 <- matrix(c(42,0,0, 8.5),nrow=2)
phis <- c(0.4, 0.2, 0.4) # Mixture probabilities.
em_funct <- function(dat, mu1, mu2, mu3, var1, var2, var3){
df <- data.frame()
for (n_point in 1:10){
#Expectation step
#n_point=2
#Computing probability that a point came from the three above defined     gaussian distributions
point <- dat[n_point,]
p1 <- dmvnorm(point,mu1,var1)
p2 <- dmvnorm(point,mu2,var2)
p3 <- dmvnorm(point,mu3,var3)
#Soft assignment of probabilities using phi
r1 <- phis[1]*p1/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r2 <- phis[2]*p2/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r3 <- phis[3]*p3/(p1*phis[1]+p2*phis[2]+p3*phis[3])
newRow <- data.frame(dat[n_point,1],dat[n_point,2],p1 ,r1, p2, r2, p3, r3)
df <- rbind(df,newRow)
}
print (df)
#Maximization step
#Compute mean and variance now as we know the responsibilites
#Mean of distribution 1
mean_x_1 <- sum(df$dat.n_point..1.*df$r1)/sum(df$r1)
mean_y_1 <- sum(df$dat.n_point..2.*df$r1)/sum(df$r1)
mean1 <- c(mean_x_1,mean_y_1)
#Mean of distribution 2
mean_x_2 <- sum(df$dat.n_point..1.*df$r2)/sum(df$r2)
mean_y_2 <- sum(df$dat.n_point..2.*df$r2)/sum(df$r2)
mean2 <- c(mean_x_2,mean_y_2)
#Mean of distribution 3
mean_x_3 <- sum(df$dat.n_point..1.*df$r3)/sum(df$r3)
mean_y_3 <- sum(df$dat.n_point..2.*df$r3)/sum(df$r3)
mean3 <- c(mean_x_3,mean_y_3)
#Variance of distribution 1
var_x_1 <- sum(df$r1*(df$dat.n_point..1.-mean_x_1)^2)/sum(df$r1)
var_y_1 <- sum(df$r1*(df$dat.n_point..2.-mean_y_1)^2)/sum(df$r1)
variance1 <- matrix(c(var_x_1,0,0,var_y_1),nrow=2)
#Variance of distribution 2
var_x_2 <- sum(df$r2*(df$dat.n_point..1.-mean_x_2)^2)/sum(df$r2)
var_y_2 <- sum(df$r2*(df$dat.n_point..2.-mean_y_2)^2)/sum(df$r2)
variance2 <- matrix(c(var_x_2,0,0,var_y_2),nrow=2)
#Variance of distribution 3
var_x_3 <- sum(df$r3*(df$dat.n_point..1.-mean_x_3)^2)/sum(df$r3)
var_y_3 <- sum(df$r3*(df$dat.n_point..2.-mean_y_3)^2)/sum(df$r3)
variance3 <- matrix(c(var_x_3,0,0,var_y_3),nrow=2)
#Computing mixing probability
phis_1 <- sum(df$r1)/500
phis_2 <- sum(df$r2)/500
phis_3 <- sum(df$r3)/500
phis_new <- c(phis_1,phis_2,phis_3)
}
for (iteration in 1:2) {
em_funct(dat,mu1, mu2, mu3, var1, var2, var3)
mu1 = mean1
mu2 = mean2
mu3 = mean3
var1 = variance1
var2 = variance2
var3 = variance3
phis = phis_new
}
#Converting var into matrix in order to inout it into dmvnorm function
mu1 <- c(-10, -8)  # Mean of cluster 1
var1 <- matrix(c(3,0,0,2),nrow=2)    # Variances of cluster 1
mu2 <- c(12, -4)   # Mean of cluster 2
var2 <- matrix(c(4,0,0, 2.5),nrow=2)  # ...etc...
mu3 <- c(4, 18)
var3 <- matrix(c(42,0,0, 8.5),nrow=2)
phis <- c(0.4, 0.2, 0.4) # Mixture probabilities.
em_funct <- function(dat, mu1, mu2, mu3, var1, var2, var3){
df <- data.frame()
for (n_point in 1:500){
#Expectation step
#n_point=2
#Computing probability that a point came from the three above defined     gaussian distributions
point <- dat[n_point,]
p1 <- dmvnorm(point,mu1,var1)
p2 <- dmvnorm(point,mu2,var2)
p3 <- dmvnorm(point,mu3,var3)
#Soft assignment of probabilities using phi
r1 <- phis[1]*p1/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r2 <- phis[2]*p2/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r3 <- phis[3]*p3/(p1*phis[1]+p2*phis[2]+p3*phis[3])
newRow <- data.frame(dat[n_point,1],dat[n_point,2],p1 ,r1, p2, r2, p3, r3)
df <- rbind(df,newRow)
}
print (df)
#Maximization step
#Compute mean and variance now as we know the responsibilites
#Mean of distribution 1
mean_x_1 <- sum(df$dat.n_point..1.*df$r1)/sum(df$r1)
mean_y_1 <- sum(df$dat.n_point..2.*df$r1)/sum(df$r1)
mean1 <- c(mean_x_1,mean_y_1)
#Mean of distribution 2
mean_x_2 <- sum(df$dat.n_point..1.*df$r2)/sum(df$r2)
mean_y_2 <- sum(df$dat.n_point..2.*df$r2)/sum(df$r2)
mean2 <- c(mean_x_2,mean_y_2)
#Mean of distribution 3
mean_x_3 <- sum(df$dat.n_point..1.*df$r3)/sum(df$r3)
mean_y_3 <- sum(df$dat.n_point..2.*df$r3)/sum(df$r3)
mean3 <- c(mean_x_3,mean_y_3)
#Variance of distribution 1
var_x_1 <- sum(df$r1*(df$dat.n_point..1.-mean_x_1)^2)/sum(df$r1)
var_y_1 <- sum(df$r1*(df$dat.n_point..2.-mean_y_1)^2)/sum(df$r1)
variance1 <- matrix(c(var_x_1,0,0,var_y_1),nrow=2)
#Variance of distribution 2
var_x_2 <- sum(df$r2*(df$dat.n_point..1.-mean_x_2)^2)/sum(df$r2)
var_y_2 <- sum(df$r2*(df$dat.n_point..2.-mean_y_2)^2)/sum(df$r2)
variance2 <- matrix(c(var_x_2,0,0,var_y_2),nrow=2)
#Variance of distribution 3
var_x_3 <- sum(df$r3*(df$dat.n_point..1.-mean_x_3)^2)/sum(df$r3)
var_y_3 <- sum(df$r3*(df$dat.n_point..2.-mean_y_3)^2)/sum(df$r3)
variance3 <- matrix(c(var_x_3,0,0,var_y_3),nrow=2)
#Computing mixing probability
phis_1 <- sum(df$r1)/500
phis_2 <- sum(df$r2)/500
phis_3 <- sum(df$r3)/500
phis_new <- c(phis_1,phis_2,phis_3)
}
for (iteration in 1:2) {
em_funct(dat,mu1, mu2, mu3, var1, var2, var3)
mu1 = mean1
mu2 = mean2
mu3 = mean3
var1 = variance1
var2 = variance2
var3 = variance3
phis = phis_new
}
#Converting var into matrix in order to inout it into dmvnorm function
mu1 <- c(-10, -8)  # Mean of cluster 1
var1 <- matrix(c(3,0,0,2),nrow=2)    # Variances of cluster 1
mu2 <- c(12, -4)   # Mean of cluster 2
var2 <- matrix(c(4,0,0, 2.5),nrow=2)  # ...etc...
mu3 <- c(4, 18)
var3 <- matrix(c(42,0,0, 8.5),nrow=2)
phis <- c(0.4, 0.2, 0.4) # Mixture probabilities.
em_funct <- function(dat, mu1, mu2, mu3, var1, var2, var3){
df <- data.frame()
for (n_point in 1:500){
#Expectation step
#n_point=2
#Computing probability that a point came from the three above defined     gaussian distributions
point <- dat[n_point,]
p1 <- dmvnorm(point,mu1,var1)
p2 <- dmvnorm(point,mu2,var2)
p3 <- dmvnorm(point,mu3,var3)
#Soft assignment of probabilities using phi
r1 <- phis[1]*p1/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r2 <- phis[2]*p2/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r3 <- phis[3]*p3/(p1*phis[1]+p2*phis[2]+p3*phis[3])
newRow <- data.frame(dat[n_point,1],dat[n_point,2],p1 ,r1, p2, r2, p3, r3)
df <- rbind(df,newRow)
}
print (df)
#Maximization step
#Compute mean and variance now as we know the responsibilites
#Mean of distribution 1
mean_x_1 <- sum(df$dat.n_point..1.*df$r1)/sum(df$r1)
mean_y_1 <- sum(df$dat.n_point..2.*df$r1)/sum(df$r1)
mean1 <- c(mean_x_1,mean_y_1)
#Mean of distribution 2
mean_x_2 <- sum(df$dat.n_point..1.*df$r2)/sum(df$r2)
mean_y_2 <- sum(df$dat.n_point..2.*df$r2)/sum(df$r2)
mean2 <- c(mean_x_2,mean_y_2)
#Mean of distribution 3
mean_x_3 <- sum(df$dat.n_point..1.*df$r3)/sum(df$r3)
mean_y_3 <- sum(df$dat.n_point..2.*df$r3)/sum(df$r3)
mean3 <- c(mean_x_3,mean_y_3)
#Variance of distribution 1
var_x_1 <- sum(df$r1*(df$dat.n_point..1.-mean_x_1)^2)/sum(df$r1)
var_y_1 <- sum(df$r1*(df$dat.n_point..2.-mean_y_1)^2)/sum(df$r1)
variance1 <- matrix(c(var_x_1,0,0,var_y_1),nrow=2)
#Variance of distribution 2
var_x_2 <- sum(df$r2*(df$dat.n_point..1.-mean_x_2)^2)/sum(df$r2)
var_y_2 <- sum(df$r2*(df$dat.n_point..2.-mean_y_2)^2)/sum(df$r2)
variance2 <- matrix(c(var_x_2,0,0,var_y_2),nrow=2)
#Variance of distribution 3
var_x_3 <- sum(df$r3*(df$dat.n_point..1.-mean_x_3)^2)/sum(df$r3)
var_y_3 <- sum(df$r3*(df$dat.n_point..2.-mean_y_3)^2)/sum(df$r3)
variance3 <- matrix(c(var_x_3,0,0,var_y_3),nrow=2)
#Computing mixing probability
phis_1 <- sum(df$r1)/500
phis_2 <- sum(df$r2)/500
phis_3 <- sum(df$r3)/500
phis_new <- c(phis_1,phis_2,phis_3)
}
for (iteration in 1:6) {
em_funct(dat,mu1, mu2, mu3, var1, var2, var3)
mu1 = mean1
mu2 = mean2
mu3 = mean3
var1 = variance1
var2 = variance2
var3 = variance3
phis = phis_new
}
max(r1,r2,r3)
#Converting var into matrix in order to inout it into dmvnorm function
mu1 <- c(-10, -8)  # Mean of cluster 1
var1 <- matrix(c(3,0,0,2),nrow=2)    # Variances of cluster 1
mu2 <- c(12, -4)   # Mean of cluster 2
var2 <- matrix(c(4,0,0, 2.5),nrow=2)  # ...etc...
mu3 <- c(4, 18)
var3 <- matrix(c(42,0,0, 8.5),nrow=2)
phis <- c(0.4, 0.2, 0.4) # Mixture probabilities.
em_funct <- function(dat, mu1, mu2, mu3, var1, var2, var3){
df <- data.frame()
for (n_point in 1:500){
#Expectation step
#n_point=2
#Computing probability that a point came from the three above defined     gaussian distributions
point <- dat[n_point,]
p1 <- dmvnorm(point,mu1,var1)
p2 <- dmvnorm(point,mu2,var2)
p3 <- dmvnorm(point,mu3,var3)
#Soft assignment of probabilities using phi
r1 <- phis[1]*p1/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r2 <- phis[2]*p2/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r3 <- phis[3]*p3/(p1*phis[1]+p2*phis[2]+p3*phis[3])
newRow <- data.frame(dat[n_point,1],dat[n_point,2],p1 ,r1, p2, r2, p3, r3,max(r1,r2,r3))
df <- rbind(df,newRow)
}
print (df)
#Maximization step
#Compute mean and variance now as we know the responsibilites
#Mean of distribution 1
mean_x_1 <- sum(df$dat.n_point..1.*df$r1)/sum(df$r1)
mean_y_1 <- sum(df$dat.n_point..2.*df$r1)/sum(df$r1)
mean1 <- c(mean_x_1,mean_y_1)
#Mean of distribution 2
mean_x_2 <- sum(df$dat.n_point..1.*df$r2)/sum(df$r2)
mean_y_2 <- sum(df$dat.n_point..2.*df$r2)/sum(df$r2)
mean2 <- c(mean_x_2,mean_y_2)
#Mean of distribution 3
mean_x_3 <- sum(df$dat.n_point..1.*df$r3)/sum(df$r3)
mean_y_3 <- sum(df$dat.n_point..2.*df$r3)/sum(df$r3)
mean3 <- c(mean_x_3,mean_y_3)
#Variance of distribution 1
var_x_1 <- sum(df$r1*(df$dat.n_point..1.-mean_x_1)^2)/sum(df$r1)
var_y_1 <- sum(df$r1*(df$dat.n_point..2.-mean_y_1)^2)/sum(df$r1)
variance1 <- matrix(c(var_x_1,0,0,var_y_1),nrow=2)
#Variance of distribution 2
var_x_2 <- sum(df$r2*(df$dat.n_point..1.-mean_x_2)^2)/sum(df$r2)
var_y_2 <- sum(df$r2*(df$dat.n_point..2.-mean_y_2)^2)/sum(df$r2)
variance2 <- matrix(c(var_x_2,0,0,var_y_2),nrow=2)
#Variance of distribution 3
var_x_3 <- sum(df$r3*(df$dat.n_point..1.-mean_x_3)^2)/sum(df$r3)
var_y_3 <- sum(df$r3*(df$dat.n_point..2.-mean_y_3)^2)/sum(df$r3)
variance3 <- matrix(c(var_x_3,0,0,var_y_3),nrow=2)
#Computing mixing probability
phis_1 <- sum(df$r1)/500
phis_2 <- sum(df$r2)/500
phis_3 <- sum(df$r3)/500
phis_new <- c(phis_1,phis_2,phis_3)
}
for (iteration in 1:6) {
em_funct(dat,mu1, mu2, mu3, var1, var2, var3)
mu1 = mean1
mu2 = mean2
mu3 = mean3
var1 = variance1
var2 = variance2
var3 = variance3
phis = phis_new
}
ggplot(df,aes(df$dat.n_point..1.,df$dat.n_point..2.))+
geom_point()
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(mclust)
library(readr)
library(dplyr)
library(tidyr)
library(broom)
library(mvtnorm)
import <- readRDS("data/clusterData.rds")
dat <- import$X
#Converting var into matrix in order to inout it into dmvnorm function
mu1 <- c(-10, -8)  # Mean of cluster 1
var1 <- matrix(c(3,0,0,2),nrow=2)    # Variances of cluster 1
mu2 <- c(12, -4)   # Mean of cluster 2
var2 <- matrix(c(4,0,0, 2.5),nrow=2)  # ...etc...
mu3 <- c(4, 18)
var3 <- matrix(c(42,0,0, 8.5),nrow=2)
phis <- c(0.4, 0.2, 0.4) # Mixture probabilities.
em_funct <- function(dat, mu1, mu2, mu3, var1, var2, var3){
df <- data.frame()
for (n_point in 1:500){
#Expectation step
#n_point=2
#Computing probability that a point came from the three above defined     gaussian distributions
point <- dat[n_point,]
p1 <- dmvnorm(point,mu1,var1)
p2 <- dmvnorm(point,mu2,var2)
p3 <- dmvnorm(point,mu3,var3)
#Soft assignment of probabilities using phi
r1 <- phis[1]*p1/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r2 <- phis[2]*p2/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r3 <- phis[3]*p3/(p1*phis[1]+p2*phis[2]+p3*phis[3])
newRow <- data.frame(dat[n_point,1],dat[n_point,2],p1 ,r1, p2, r2, p3, r3,max(r1,r2,r3))
df <- rbind(df,newRow)
}
print (df)
#Maximization step
#Compute mean and variance now as we know the responsibilites
#Mean of distribution 1
mean_x_1 <- sum(df$dat.n_point..1.*df$r1)/sum(df$r1)
mean_y_1 <- sum(df$dat.n_point..2.*df$r1)/sum(df$r1)
mean1 <- c(mean_x_1,mean_y_1)
#Mean of distribution 2
mean_x_2 <- sum(df$dat.n_point..1.*df$r2)/sum(df$r2)
mean_y_2 <- sum(df$dat.n_point..2.*df$r2)/sum(df$r2)
mean2 <- c(mean_x_2,mean_y_2)
#Mean of distribution 3
mean_x_3 <- sum(df$dat.n_point..1.*df$r3)/sum(df$r3)
mean_y_3 <- sum(df$dat.n_point..2.*df$r3)/sum(df$r3)
mean3 <- c(mean_x_3,mean_y_3)
#Variance of distribution 1
var_x_1 <- sum(df$r1*(df$dat.n_point..1.-mean_x_1)^2)/sum(df$r1)
var_y_1 <- sum(df$r1*(df$dat.n_point..2.-mean_y_1)^2)/sum(df$r1)
variance1 <- matrix(c(var_x_1,0,0,var_y_1),nrow=2)
#Variance of distribution 2
var_x_2 <- sum(df$r2*(df$dat.n_point..1.-mean_x_2)^2)/sum(df$r2)
var_y_2 <- sum(df$r2*(df$dat.n_point..2.-mean_y_2)^2)/sum(df$r2)
variance2 <- matrix(c(var_x_2,0,0,var_y_2),nrow=2)
#Variance of distribution 3
var_x_3 <- sum(df$r3*(df$dat.n_point..1.-mean_x_3)^2)/sum(df$r3)
var_y_3 <- sum(df$r3*(df$dat.n_point..2.-mean_y_3)^2)/sum(df$r3)
variance3 <- matrix(c(var_x_3,0,0,var_y_3),nrow=2)
#Computing mixing probability
phis_1 <- sum(df$r1)/500
phis_2 <- sum(df$r2)/500
phis_3 <- sum(df$r3)/500
phis_new <- c(phis_1,phis_2,phis_3)
}
for (iteration in 1:6) {
em_funct(dat,mu1, mu2, mu3, var1, var2, var3)
mu1 = mean1
mu2 = mean2
mu3 = mean3
var1 = variance1
var2 = variance2
var3 = variance3
phis = phis_new
}
#Converting var into matrix in order to inout it into dmvnorm function
mu1 <- c(-10, -8)  # Mean of cluster 1
var1 <- matrix(c(3,0,0,2),nrow=2)    # Variances of cluster 1
mu2 <- c(12, -4)   # Mean of cluster 2
var2 <- matrix(c(4,0,0, 2.5),nrow=2)  # ...etc...
mu3 <- c(4, 18)
var3 <- matrix(c(42,0,0, 8.5),nrow=2)
phis <- c(0.4, 0.2, 0.4) # Mixture probabilities.
em_funct <- function(dat, mu1, mu2, mu3, var1, var2, var3){
df <- data.frame()
for (n_point in 1:500){
#Expectation step
#n_point=2
#Computing probability that a point came from the three above defined     gaussian distributions
point <- dat[n_point,]
p1 <- dmvnorm(point,mu1,var1)
p2 <- dmvnorm(point,mu2,var2)
p3 <- dmvnorm(point,mu3,var3)
#Soft assignment of probabilities using phi
r1 <- phis[1]*p1/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r2 <- phis[2]*p2/(p1*phis[1]+p2*phis[2]+p3*phis[3])
r3 <- phis[3]*p3/(p1*phis[1]+p2*phis[2]+p3*phis[3])
newRow <- data.frame(dat[n_point,1],dat[n_point,2],p1 ,r1, p2, r2, p3, r3,max(r1,r2,r3))
df <- rbind(df,newRow)
}
print (df)
#Maximization step
#Compute mean and variance now as we know the responsibilites
#Mean of distribution 1
mean_x_1 <- sum(df$dat.n_point..1.*df$r1)/sum(df$r1)
mean_y_1 <- sum(df$dat.n_point..2.*df$r1)/sum(df$r1)
mean1 <- c(mean_x_1,mean_y_1)
#Mean of distribution 2
mean_x_2 <- sum(df$dat.n_point..1.*df$r2)/sum(df$r2)
mean_y_2 <- sum(df$dat.n_point..2.*df$r2)/sum(df$r2)
mean2 <- c(mean_x_2,mean_y_2)
#Mean of distribution 3
mean_x_3 <- sum(df$dat.n_point..1.*df$r3)/sum(df$r3)
mean_y_3 <- sum(df$dat.n_point..2.*df$r3)/sum(df$r3)
mean3 <- c(mean_x_3,mean_y_3)
#Variance of distribution 1
var_x_1 <- sum(df$r1*(df$dat.n_point..1.-mean_x_1)^2)/sum(df$r1)
var_y_1 <- sum(df$r1*(df$dat.n_point..2.-mean_y_1)^2)/sum(df$r1)
variance1 <- matrix(c(var_x_1,0,0,var_y_1),nrow=2)
#Variance of distribution 2
var_x_2 <- sum(df$r2*(df$dat.n_point..1.-mean_x_2)^2)/sum(df$r2)
var_y_2 <- sum(df$r2*(df$dat.n_point..2.-mean_y_2)^2)/sum(df$r2)
variance2 <- matrix(c(var_x_2,0,0,var_y_2),nrow=2)
#Variance of distribution 3
var_x_3 <- sum(df$r3*(df$dat.n_point..1.-mean_x_3)^2)/sum(df$r3)
var_y_3 <- sum(df$r3*(df$dat.n_point..2.-mean_y_3)^2)/sum(df$r3)
variance3 <- matrix(c(var_x_3,0,0,var_y_3),nrow=2)
#Computing mixing probability
phis_1 <- sum(df$r1)/500
phis_2 <- sum(df$r2)/500
phis_3 <- sum(df$r3)/500
phis_new <- c(phis_1,phis_2,phis_3)
}
for (iteration in 1:6) {
em_funct(dat,mu1, mu2, mu3, var1, var2, var3)
mu1 = mean1
mu2 = mean2
mu3 = mean3
var1 = variance1
var2 = variance2
var3 = variance3
phis = phis_new
}
shiny::runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
eq_data$Type
#Loading raw data
dat <- read_csv("/Users/Tarini/Documents/Earthquake_ShinyApp/data/database.csv")
dat$Type
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
dat %>% filter(Type=="Nuclear Explosion")
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
test <- dat %>% filter(Type=="Nuclear Explosion")
View(test)
test <- dat %>% filter(Type %ini% c("Nuclear Explosion"))
test <- dat %>% filter(Type %in% c("Nuclear Explosion"))
View(test)
View(test)
View(test)
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
runApp('Documents/Earthquake_ShinyApp/EQ_Shiny')
e
exp(16)
exp^16
0.9-1
0.5-1-1.5
#Loading raw data
data <- read.table("../data/raw_data.data", fileEncoding="UTF-16", dec=",")
#Loading raw data
data <- read.table("raw_data.data", fileEncoding="UTF-16", dec=",")
getwd()
setwd("~/Documents/MachineLearning_Mushroom")
#Loading raw data
data <- read.table("data/raw_data.data", fileEncoding="UTF-16", dec=",")
#Loading raw data
data <- read.table("data/raw_data.data", fileEncoding="UTF-16", dec=",")
#Loading raw data
data <- read.table("data/raw_data.data",header=F,sep=";")
View(data)
#Loading raw data
data <- read.table("data/raw_data.data",header=F,sep=",")
View(data)
View(data)
dat_complete <- data[complete.cases(data),]
View(data)
dat$V12
data$V12
data$V12="?"
summary(data)
colnames(data) <- c("class",
"cap_shape",
"cap_surface",
"cap_color",
"bruises",
"odor",
"gill_attachment",
"gill-spacing",
"gill-size",
"gill-color",
"stalk-shape",
"stalk-root",
"stalk-surface-above-ring",
"stalk-surface-below-ring",
"stalk-color-above-ring",
"stalk-color-below-ring",
"veil-type",
"veil-color",
"ring-number",
"ring-type",
"spore-print-color",
"population",
"habitat")
View(data)
write.csv(data/mushroom_data,row.names=FALSE)
write.csv(data,file="data/mushroom_data.csv",row.names=FALSE)
View(data)
